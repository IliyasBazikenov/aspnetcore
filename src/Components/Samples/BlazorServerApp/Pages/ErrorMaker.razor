@page "/errormaker"

<fieldset>
    <legend>Error maker</legend>

    <fieldset>
        <legend>Event handlers</legend>
        <button @onclick="@EventHandlerErrorSync">Synchronous</button>
        <button @onclick="@EventHandlerErrorAsync">Asynchronous</button>
    </fieldset>

    <fieldset>
        <legend>Lifecycle methods</legend>
        <div><label><input @bind="throwInOnParametersSet" type="checkbox" /> OnParametersSet (sync)</label></div>
        <div><label><input @bind="throwInOnParametersSetAsync" type="checkbox" /> OnParametersSetAsync (async)</label></div>
        <div><label><input @bind="throwInOnAfterRender" type="checkbox" /> OnAfterRender (sync)</label></div>
        <div><label><input @bind="throwInOnAfterRenderAsync" type="checkbox" /> OnAfterRenderAsync (async)</label></div>
        <ErrorCausingChild ThrowOnParametersSet="@throwInOnParametersSet"
                           ThrowOnParametersSetAsync="@throwInOnParametersSetAsync"
                           ThrowOnAfterRender="@throwInOnAfterRender"
                           ThrowOnAfterRenderAsync="@throwInOnAfterRenderAsync" />
    </fieldset>

    <fieldset>
        <legend>Rendering</legend>
        <label><input @bind="throwWhileRendering" type="checkbox" /> Throw during rendering</label>
        @if (throwWhileRendering)
        {
            throw new InvalidTimeZoneException($"Exception from {nameof(BuildRenderTree)}");
        }
    </fieldset>
</fieldset>

@code {
    // Also consider:
    // - InvokeAsync
    // - SetParametersAsync being triggered by a cascading parameter subscription

    // I'm proposing not to allow handling exceptions that occur during either IComponentActivator.CreateInstance or
    // IComponent.Attach, because:
    // [1] For most applications, these won't run any developer-supplied code, and will only run the framework's
    //     built-in logic (e.g., ComponentBase.Attach which can't throw). The value here is pretty low.
    // [2] Supporting recovery from these is difficult and leads to entirely new states, such as a "component" RenderTreeFrame
    //     not actually having an associated ComponentState because we never initialized it in the first place.
    // These particular lifecycle points are outside the scope of error recovery that could be achieved in user code today
    // (via the "cascading a custom ErrorBoundary-type component" technique), so are outside the scope of this work. We retain
    // the option of making component initialization errors recoverable in the future, as I think it's fair to say that would
    // not be a breaking change, as we'd be replacing a previously-fatal error with a nonfatal one.

    // After a lot of consideration, I don't think we should allow exceptions during Dispose/DisposeAsync to be recoverable.
    // We could do so, since components are only disposed once they are removed from their parents, so even if their disposal
    // fails we know they are gone from the component hierarchy anyway, and we can still be sure to clean up all the framework
    // managed resources for them and their descendants. However, if disposal throws, then it's very likely that the application
    // cleanup logic didn't complete properly, and hence the application is now leaking memory. It's not smart to have a default
    // behavior that lets the developer get away with randomly incomplete cleanup. If a developer really wants to opt into this
    // on a per-Dispose/DisposeAsync basis, they can use a try/catch there, and in most cases they should not do so.

    private bool throwInOnParametersSet;
    private bool throwInOnParametersSetAsync;
    private bool throwInOnAfterRender;
    private bool throwInOnAfterRenderAsync;
    private bool throwWhileRendering;

    void EventHandlerErrorSync()
        => throw new InvalidTimeZoneException("Synchronous error from event handler");

    async Task EventHandlerErrorAsync()
    {
        await Task.Yield();
        throw new InvalidTimeZoneException("Asynchronous error from event handler");
    }
}
