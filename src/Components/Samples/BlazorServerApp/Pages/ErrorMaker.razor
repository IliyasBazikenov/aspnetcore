@page "/errormaker"

<fieldset>
    <legend>Error maker</legend>

    <fieldset>
        <legend>Event handlers</legend>
        <button @onclick="@EventHandlerErrorSync">Synchronous</button>
        <button @onclick="@EventHandlerErrorAsync">Asynchronous</button>
    </fieldset>

    <fieldset>
        <legend>Lifecycle methods</legend>
        <div><label><input @bind="throwInOnParametersSet" type="checkbox" /> OnParametersSet (sync)</label></div>
        <div><label><input @bind="throwInOnParametersSetAsync" type="checkbox" /> OnParametersSetAsync (async)</label></div>
        <div><label><input @bind="throwInOnAfterRender" type="checkbox" /> OnAfterRender (sync)</label></div>
        <div><label><input @bind="throwInOnAfterRenderAsync" type="checkbox" /> OnAfterRenderAsync (async)</label></div>
        <ErrorCausingChild ThrowOnParametersSet="@throwInOnParametersSet"
                           ThrowOnParametersSetAsync="@throwInOnParametersSetAsync"
                           ThrowOnAfterRender="@throwInOnAfterRender"
                           ThrowOnAfterRenderAsync="@throwInOnAfterRenderAsync" />
    </fieldset>

    <fieldset>
        <legend>Rendering</legend>
        <label><input @bind="throwWhileRendering" type="checkbox" /> Throw during rendering</label>
        @if (throwWhileRendering)
        {
            throw new InvalidTimeZoneException($"Exception from {nameof(BuildRenderTree)}");
        }
    </fieldset>
</fieldset>

@code {
    // Also consider:
    // - Attach
    // - InvokeAsync
    // - SetParametersAsync being triggered by a cascading parameter subscription

    // After a lot of consideration, I don't think we should allow exceptions during Dispose/DisposeAsync to be recoverable.
    // We could do so, since components are only disposed once they are removed from their parents, so even if their disposal
    // fails we know they are gone from the component hierarchy anyway, and we can still be sure to clean up all the framework
    // managed resources for them and their descendants. However, if disposal throws, then it's very likely that the application
    // cleanup logic didn't complete properly, and hence the application is now leaking memory. It's not smart to have a default
    // behavior that lets the developer get away with randomly incomplete cleanup. If a developer really wants to opt into this
    // on a per-Dispose/DisposeAsync basis, they can use a try/catch there, and in most cases they should not do so.

    private bool throwInOnParametersSet;
    private bool throwInOnParametersSetAsync;
    private bool throwInOnAfterRender;
    private bool throwInOnAfterRenderAsync;
    private bool throwWhileRendering;

    void EventHandlerErrorSync()
        => throw new InvalidTimeZoneException("Synchronous error from event handler");

    async Task EventHandlerErrorAsync()
    {
        await Task.Yield();
        throw new InvalidTimeZoneException("Asynchronous error from event handler");
    }
}
